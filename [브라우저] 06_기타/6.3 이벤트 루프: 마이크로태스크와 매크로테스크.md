브라우저나 Node.js 자바스크립트 실행 흐름은 이벤트 루프에 기반합니다.

<br>

# 이벤트 루프

이벤트 루프(event loop)는 태스크가 들어오길 기다렸다가 들어오면 처리하고, 처리할 태스크가 없는 경우엔 잠드는, 끊임없이 돌아가는 자바스크립트 내 루프입니다.  
자바스크립트 엔진이 돌아가는 알고리즘은: 

1. 처리할 태스크가 있는 경우: 먼저 들어온 태스크부터 순차적으로 처리함
2. 처리할 태스크가 없는 경우: 잠들어 있다가 새로운 태스크가 추가되면 1로 돌아감

태스크는 하나의 집합을 이룹니다. 어떤 태스크가 자바스크립트 엔진을 활성화할까요? 대표적으론:

- 외부 스크립트 `<script src="...">`가 로드될 때, 이 스크립트를 실행하는 것
- 사용자가 마우스를 움직일 때 `mousemove` 이벤트와 이벤트 핸들러를 실행하는 것
- `setTimeout` 시간이 다 된 경우, 콜백 함수를 실행하는 것

태스크를 기다리는 동안엔 CPU 자원 소비는 0에 가까워지고 엔진은 잠들게 됩니다.

새로운 태스크가 엔진이 바쁠 때 추가된다면, 태스크는 큐에 추가됩니다. 이를 V8 용어로 **'매크로태스크 큐(macrotask queue)'** 라고 부릅니다.

<br>

**예를 들어...**

엔진이 `script`를 처리하던 중 마우스가 움직여 `mousemove` 이벤트가 발생하고, 이어 `setTimeout` 시간이 지난 상황입니다. 세 태스크는 아래 그림처럼 큐에 하나씩 추가됩니다. 큐의 태스크들은 ‘들어간 순서대로’ 처리됩니다.

![image](https://user-images.githubusercontent.com/65887537/206438041-84e48129-9b76-4380-9d9f-b7211513ff33.png)

여기서 잠시 두 가지 세부 사항을 짚고 넘어갑시다.

1. 엔진이 특정 **태스크를 처리하는 동안엔 렌더링이 절대 일어나지 않습니다.** 처리 시간이 짧으면 끝나는 대로 DOM 변경을 화면에 반영하면 되기 때문에 전혀 문제되지 않습니다.
2. 처리에 긴 시간이 걸리면, 브라우저는 그동안 발생한 사용자 이벤트 등 새로운 태스크를 처리하지 못합니다. 
   _(ex. 인터넷 서핑 중 '응답 없는 페이지(Page Unresponsive)'라는 얼럿 창을 만나게 되는데, 복잡한 계산이나 프로그래밍 에러 때문에 무한 루프에 빠질 때 나타납니다. 브라우저는 얼럿 창으로 사용자가 페이지 전체와 함께 해당 태스크를 취소시킬지 선택하도록 유도합니다.)_

<br>

이 지식을 실무에서 활용해봅시다.

<br>

# Use case 1: CPU 소모가 많은 태스크 쪼개기

페이지에서 코드의 일부를 강조(highlight)하는 것이 이런 태스크에 속합니다. 강조할 부분을 사전 분석하고, 색을 변경한 요소를 새롭게 만들고 문서에 추가하는 일련의 작업이 필요합니다. 코드 많아질 수록 오래 걸리죠.

이걸 처리하느라 엔진이 바쁘면 사용자 이벤트 처리나 DOM 관련 작업이 멈추기 때문에, 브라우저가 지연되거나 멈추기도 합니다.

이는 태스크를 **여러 조각으로 쪼개 예방**할 수 있습니다. 처음 100줄만 먼저 강조하고, 지연시간이 0인 `setTimeout`을 사용해 새롭게 스케줄링을 한 다음, 그 다음 100줄을 강조하는 식으로요.

전체 실행 시간을 많이 희생하지 않으면서도 사용자와의 상호작용이 막히지 않는다는 장점이 있습니다.

<br>

1부터 1000000000까지의 숫자를 세는 함수를 봅시다.

리팩토링 전의 코드는 엔진이 몇 초간 ‘멈춥니다’. (서버 사이드 환경에선 멈춤 현상이 잘 보이는데 브라우저에선 실행 후 마우스 오른쪽 버튼 등을 클릭해 확인 가능) 숫자를 다 세고 얼럿 창이 뜨기 전까진 사용자 이벤트가 처리되지 않습니다. 저사양 머신에는 'the script takes too long' 경고가 뜰 수도 있습니다.

```js
let i = 0;
let start = Date.now();

function count() {
  for (let j = 0; j < 1e9; j++) {
    i++;
  }
  alert("처리에 걸린 시간: " + (Date.now() - start) + "ms");
}

count();
```

<br>

이제 중첩 `setTimeout`으로 쪼개봅시다. 브라우저가 멈춤 없이 동작합니다. 엔진이 첫번째 카운팅 중 새로운 태스크가 생기면, 큐에 들어가고, 첫번째 카운팅이 끝나고 두번째 카운팅이 시작되기 전 실행됩니다.

```js
let i = 0;
let start = Date.now();

function count() {
  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("처리에 걸린 시간: " + (Date.now() - start) + "ms");
  } else {
    setTimeout(count);
  }
}

count();
```

<br>

다만 이전 예시와 조금의 시간차가 있네요. 카운팅이 시작되기 전에 재스캐줄링하면 시간차를 줄일 수 있습니다. 왜일까요?

[`setTimeout/setInterval`](https://ko.javascript.info/settimeout-setinterval) 챕터에서 배웠듯 중첩 `setTimeout` 호출이 많으면 4밀리초의 최소 대기 시간이 생기기 때문입니다. 카운팅 전에 스케줄링하면 대기 시간을 소모합니다. 수정해봅시다.

```js
let i = 0;
let start = Date.now();

function count() {
  if (i < 1e9 - 1e6) {
    setTimeout(count);
  }

  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("처리에 걸린 시간: " + (Date.now() - start) + "ms");
  }
}

count();
```

<br>

# Use case 2: 프로그레스 

브라우저는 작업 중인 태스크가 끝나야 DOM 변경사항을 보여줌으로써 '중간' 상태의 화면이 사용자에게 노출되는 것을 막고 혼란을 줄입니다.

그런데 프로그레스 바(progress bar) 같이 작업 진척 상태를 보여주는 인디케이터(indicator)가 필요한 경우도 있습니다. 이럴 때 태스크를 쪼개면 중간 상태를 보여줄 수 있습니다. ([예시](https://ko.javascript.info/event-loop#ref-1040:~:text=%EB%B3%BC%20%EC%88%98%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4.-,%EC%98%88%EC%8B%9C%EB%A5%BC,-%EC%82%B4%ED%8E%B4%EB%B4%85%EC%8B%9C%EB%8B%A4.))

<br>

# Use case 3: 이벤트 처리가 끝난 이후에 작업하기

이벤트 핸들러를 만들다 보면 이벤트 버블링이 끝나 모든 DOM 트리 레벨에서 이벤트가 핸들링 될 때까지 특정 액션을 연기시켜야 하는 경우가 생기곤 합니다. 이럴 때 연기시킬 코드를 지연 시간이 0인 `setTimeout`으로 감싸면 됩니다.

앞서 [커스텀 이벤트 디스패치](https://ko.javascript.info/dispatch-events#:~:text=%EC%9C%BC%EB%A1%9C%20%EA%B0%90%EC%8B%B8%EB%8A%94%20%EA%B2%83%EB%8F%84-,%EB%B0%A9%EB%B2%95%EC%9E%85%EB%8B%88%EB%8B%A4,-.) 챕터에서 커스텀 이벤트 `menu-open`을 `setTimeout` 안에서 디스패칭했는데, 이러면 `'click'` 이벤트가 완전히 핸들링 된 다음에 `menu-open` 이벤트를 디스패칭 할 수 있습니다.

<br>

# 매크로태스크와 마이크로태스크

태스크는 이번 챕터에서 설명한 **매크로태스크(macrotask)** 와 [마이크로태스크](https://ko.javascript.info/microtask-queue) 챕터에서 다룬 **마이크로태스크(microtask)** 로 나뉩니다.

마이크로태스크는 코드를 사용해서만 만들 수 있는데, 주로 프라미스를 사용해 만듭니다. `.then/catch/finally` 핸들러가 마이크로태스크가 되죠. 또다른 핸들링 문법인 `await`로 만들기도 합니다. 이 외에도 표준 API인 `queueMicrotask(func)`로 함수 `func`를 마이크로태스크 큐에 넣어 처리할 수 있습니다.

**자바스크립트 엔진은 매크로태스크 하나를 처리할 때마다 또 다른 매크로태스크나 렌더링 작업을 하기 전에 마이크로태스크 큐에 쌓인 마이크로태스크 전부를 처리합니다.**

<br>

다음 예시에선

```js
setTimeout(() => alert("timeout"));

Promise.resolve().then(() => alert("promise"));

alert("code");
```

다음 순서대로 출력됩니다.

1.`code` – 일반적인 동기 호출이므로 가장 먼저 매크로태스크 큐에 들어가 실행됩니다.
2. `promise` – 마이크로태스크 큐에 들어가 현재 코드 이후에 실행됩니다.
3. `timeout` – 가장 마지막에 매크로태스크가 실행합니다.

<br>

도식화하면: 매크로태스크(`script, mousemove, setTimeout` 등) 하나가 처리되고 난 후 마이크로태스크 전부가 처리되고 **그 이후 렌더링**이 진행됩니다.

![image](https://user-images.githubusercontent.com/65887537/206446188-3279489b-1923-4669-8fe3-6979883e2841.png)

이처럼 마이크로태스크는 다른 이벤트 핸들러나 렌더링 작업, 혹은 다른 매크로태스크가 실행되기 전에 처리됩니다.

이런 처리순서가 아주 중요한 이유는 (마우스 좌표 변경이나 네트워크 통신에 의한 데이터 변경 같이 애플리케이션 환경에 변화를 주는 작업에 영향을 받지 않고) 모든 마이크로태스크를 동일한 환경에서 처리할 수 있기 때문입니다.

그런데 개발을 하다 보면 직접 만든 함수를 현재 코드 실행이 끝난 후, 새로운 이벤트 핸들러가 처리되기 전이면서 렌더링이 실행되기 전에 비동기적으로 실행해야 하는 경우가 생기곤 합니다. 이럴 때 queueMicrotask를 사용해 커스텀 함수를 스케줄링하면 됩니다.

앞서 살펴본 ‘프로그레스 바’ 예시에서 setTimeout 대신 queueMicrotask를 사용해 함수 count를 재스케줄링해 보았습니다. 예시를 실행하면 동기 코드처럼 카운팅이 다 끝났을 때 숫자가 렌더링 되는 것을 확인할 수 있습니다.

