### 01 콜백

- 자바스크립트엔 `loadScript` 등 다양한 비동기 동작이 있고, 동작이 종료된 후에 무언가를 실행하도록 보장하는 다양한 방법이 있습니다.
- "콜백 기반 비동기 프로그래밍" 방식  
  반드시 콜백을 인수로 제공해야 합니다. 
- "오류 우선 콜백"  
  단일 콜백 함수에서 에러/성공 케이스를 모두 처리합니다.  
  콜백의 첫 번째 인수는 에러를 위한 자리이고, 두번째 인수부턴 에러가 발생하지 않았을 때 사용합니다.
- 깊은 중첩을 콜백 지옥(멸망의 피라미드)이라 합니다.   
  이를 피하는 가장 좋은 방법은 다음 챕터의 Promise입니다.

### 02 프라미스

- `new Promise(function(resolve, reject) { executor })`  
  - executor/제작 코드/실행자는 new Promise가 만들어질 때 자동으로 그리고 즉각적으로 실행됩니다.  
  - `resolve`와 `reject`는 자바스크립트에서 자체 제공하는 콜백 함수로, executor는 반드시 둘 중 하나를 호출해야 합니다.
- promise 객체는 `state`와 `result` 내부 프로퍼티를 갖습니다.
  - state: "pending", "fulfilled", "rejected"
  - result: value 또는 error
- 소비함수는 다음 메서드를 사용해 promise에 구독합니다.
  - `.then(function(result) { 성공했을 때 }, function(error) { 실패했을 때 })`
  - `.catch(function(error) { 실패했을 때 })`
  - `.finally(() => { 성공/실패했을 때 }) `
- 콜백과의 가장 큰 차이 중 하나는 콜백 함수는 하나만 가능한 것에 비해, 프라미스는 원하는 만큼 `.then`을 호출할 수 있다는 점입니다.

### 03 프라미스 체이닝

- `.then` `.catch` `.finally`는 프라미스를 반환합니다.  
  사용된 핸들러 함수에서 plain 값이 리턴되면 해당 값으로 `fulfilled` 되고,  
  프라미스를 리턴하면, 나머지 체인은 프라미스가 처리될 때까지 대기합니다.   
  처리가 완료되면 프라미스의 `result`(값 또는 에러)가 다음 체인으로 전달됩니다.
- thenable 객체는 `.then` 메서드를 가져 프라미스와 호환 가능한 객체를 말합니다.
- 확장성을 위해 비동기 동작은 항상 프라미스를 반환하도록 하는 것이 좋습니다.

### 04 프라미스와 에러 핸들링

- `.catch` 는 프라미스에서 발생한 모든 에러를 다룹니다.   
  `reject()`가 호출되거나 에러가 던져지면 가장 가까운 `rejection` 핸들러로 넘어갑니다.
- 프라미스 executor와 프라미스 핸들러 코드 주위엔 '암시적 `try..catch`'가 있습니다.  
  따라서 자동으로 에러를 잡고 거부상태의 프라미스로 변경시킵니다.  
  에러를 분석하고(커스텀 에러 클래스가 이때 도움이 됩니다) 에러를 다시 던질 수도 있습니다.
- 에러를 처리할 `.catch`가 없다면 브라우저 환경에선 `unhandledrejection` 이벤트가 트리거 됩니다. 핸들러를 사용해 처리합시다.

### 05 프라미스 API

- Promise 클래스에는 5가지 정적 메서드가 있습니다.
  1. `Promise.all(promises)` – 모든 프라미스가 이행된 후 결괏값을 담은 배열을 반환합니다. 하나라도 실패하면 즉시 거부되고, 나머지 프라미스의 결과는 무시됩니다.
  2. `Promise.allSettled(promises)` – 모든 프라미스가 처리될 때까지 기다렸다가 그 결과(`{status, value}`)를 담은 배열을 반환합니다. (최신 문법)
  3. `Promise.race(promises)` – 가장 먼저 처리된 프라미스의 결과 또는 에러를 담은 프라미스를 반환합니다.
  4. `Promise.resolve(value)` – 주어진 값을 사용해 이행 상태의 프라미스를 만듭니다.
  5. `Promise.reject(error)` – 주어진 에러를 사용해 거부 상태의 프라미스를 만듭니다.
- 실무에선 `Promise.all`을 가장 많이 사용합니다.

### 06 프라미스화

- **프라미스화(promisification)**   
  콜백을 받는 함수를 프라미스를 반환하는 함수로 바꾸는 것  
  단, 여러 번 호출할 수 있는 콜백과 달리 프라미스는 단 하나의 결과만 가질 수 있기 때문에, 콜백을 완전히 대체하지는 못합니다.
- 이후 배울 `async/await`와 함께 사용하면 더 좋습니다.   
  
### 07 마이크로태스크

- 프라미스 핸들러 `.then/catch/finally`는 항상 비동기적으로 실행됩니다.
- **`PromiseJobs`(V8 엔진에선 마이크로태스크 큐)라는 내부 큐**를 사용합니다.   
  어떤 프라미스가 준비되었을 때 이 프라미스의 핸들러가 마이크로태스크 큐에 들어갑니다.   
  현재 스크립트가 끝나 실행할 것이 아무것도 남아있지 않을 때만 자바스크립트 엔진은 큐에서 작업을 꺼내 실행합니다.
- `unhandledrejection` 이벤트는 마이크로태스크 큐 끝에서 프라미스 에러가 처리되지 못할 때 발생합니다.  

### 08 async와 await

- `async/await`로 프라미스를 쉽게 사용할 수 있습니다.
- function 앞에 `async` 키워드를 추가하면 함수는 언제나 프라미스를 반환합니다.  
  이외 값을 반환하더라도 해당 값을 이행 상태의 프라미스(resolved promise)로 감싸 반환합니다.
- async 함수 안에선 `await`를 사용할 수 있습니다. 
  - `await` 키워드를 만나면 둘러싸고있는 async 함수를 잠시 중단하고 프라미스가 처리될 때까지 기다립니다.
  - 기다리는 동안 엔진이 다른 일(다른 스크립트를 실행, 이벤트 처리 등)을 할 수 있기 때문에, CPU 리소스가 낭비되지 않습니다.
  - 처리가 완료되면, (`throw error`를 한 것처럼) 에러가 던져지거나, 프라미스 객체의 `result` 값이 반환됩니다.
  - `Promise.then`과 비슷한데, 최상위 레벨에선 사용할 수 없다는 차이가 있습니다. (단, 익명 `async` 함수로 코드를 감싸면 가능함)  
    따라서 관행처럼 `.then/catch`를 추가해 최종 결과나 처리되지 못한 에러를 다룹니다.  
  - `thenable` 객체를 받을 수 있습니다.
  - 메서드 앞에 `async`를 붙여 async 클래스 메서드를 선언할 수 있습니다.  
- `await`가 던진 에러는 `try..catch`로 잡을 수 있습니다.   
  하지만 최상위 스코프에서 비동기 처리가 필요할 때같이 `.then/catch`가 필요한 경우가 생기기 때문에 `async/await`가 프라미스를 기반으로 한다는 사실을 알고 계셔야 합니다.
- `Promise.all`도 함께 활용할 수 있습니다.
