# 'try..catch'와 에러 핸들링

에러가 발생하면 스크립트가 ‘죽고’(즉시 중단되고), 콘솔에 에러가 출력됩니다.  
`try..catch`를 사용하면 스크립트가 죽는 걸 방지하고, 에러를 ‘잡아서’ 무언가를 할 수 있게 됩니다.

<br><br>

## ‘try…catch’ 문법

```js
try {
  // 코드...
} catch (err) {
  // 에러 핸들링
}
```

동작 알고리즘:
1. 먼저, `try {...}` 안의 코드가 실행됩니다.
2. 에러가 없다면, `try` 마지막 줄까지 실행되고, `catch` 블록은 건너뜁니다.
3. 에러가 있다면, `try` 실행이 중단되고, `catch(err)` 블록으로 제어 흐름이 넘어갑니다. 
   변수 `err`(아무 이름이나 가능)는 무슨 일이 일어났는지에 대한 설명이 담긴 에러 객체를 포함합니다.
   
<br>

### 🚨 `try..catch`는 오직 런타임 에러에만 동작합니다.

`try..catch`는 실행 가능한(runnable) 코드(즉, 유효한 자바스크립트 코드)에만 동작합니다. 
중괄호 짝이 안 맞는 것처럼 문법적으로 잘못된 경우엔 동작하지 않습니다.  
자바스크립트 엔진은 코드를 읽고 난 후 코드를 실행합니다. 
코드를 읽는 중에 발생하는 에러는 'parse-time 에러’라고 부르는데, 엔진은 이 코드를 이해할 수 없기 때문에 해당 에러는 코드 안에서 복구가 불가능합니다.
유효한 코드에서 발생하는 에러는 ‘런타임 에러(runtime error)’ 혹은 '예외(exception)'라고 부릅니다.

<br>

### 🚨 `try..catch`는 동기적으로 동작합니다.

`setTimeout`처럼 ‘스케줄 된(scheduled)’ 코드에서 발생한 예외는 `try..catch`에서 잡아낼 수 없습니다.
`setTimeout`에 넘겨진 익명 함수는 엔진이 `try..catch`를 떠난 다음에서야 실행되기 때문입니다.
스케줄 된 함수 내부의 예외를 잡으려면, `try..catch`를 함수 내부에 구현해야 합니다.

<br><br>

## 에러 객체

에러가 발생하면 상세내용이 담긴 객체를 생성하고, `catch` 블록에 인수로 전달합니다.  
내장 에러 전체와 에러 객체는 두 가지 주요 프로퍼티를 가집니다.

- `name`  
  에러 이름. 정의되지 않은 변수 때문에 발생한 에러라면 "ReferenceError"가 이름이 됩니다.
- `message`  
  에러 상세 내용을 담고 있는 문자 메시지.
- 표준은 아니지만 대부분 호스트 환경에서 지원하는 프로퍼티도 있습니다.
  가장 널리 사용되는 `stack`은 현재 호출 스택. 에러를 유발한 중첩 호출들의 순서 정보를 가진 문자열로 디버깅 목적으로 사용됩니다.
  
```js
try {
  lalala; // 에러, 변수가 정의되지 않음!
} catch(err) {
  alert(err); // ReferenceError: lalala is not defined
  alert(err.name); // ReferenceError
  alert(err.message); // lalala is not defined
  alert(err.stack); // ReferenceError: lalala is not defined at ... (호출 스택)
}
```

<br><br>

## 선택적 'catch' 바인딩

에러에 대한 자세한 정보가 필요하지 않으면, catch에서 이를 생략할 수 있습니다.

<br>

### 🚨 최근에 추가되어 구식 브라우저는 폴리필이 필요합니다.

<br><br>

## ‘try…catch’ 실무에서 사용하기

스크립트가 죽도록 놔두는 대신, `catch` 블록 안에서 새로운 네트워크 요청 보내기, 
사용자에게 대안 제안하기, 로깅 장치에 에러 정보 보내기 등과 같은 구체적인 일을 할 수 있습니다. 

<br><br>

## `throw` 연산자로 직접 에러를 만들어서 던지기

throw 연산자는 에러를 생성합니다.

```js
throw <error obj>
```

이론적으로는 원시형 자료를 포함한 어떤 것이든 에러 객체로 사용할 수 있지만,
내장 에러와의 호환을 위해 되도록 에러 객체에 **`name`과 `message` 프로퍼티를 넣어주는 것을 권장**합니다.

자바스크립트는 `Error`, `SyntaxError`, `ReferenceError`, `TypeError`등의 표준 에러 객체 관련 생성자를 지원합니다. 
이 생성자들을 이용해 에러 객체를 만들 수도 있습니다.

내장 생성자를 사용해 만든 에러 객체의 `name` 프로퍼티 값은 생성자 이름입니다. 
`message` 프로퍼티의 값은 인수에서 가져옵니다.

```js
let error = new Error(message);
```

<br><br>

## 에러 다시 던지기

에러 종류와 관계없이 동일한 방식으로 처리하는 것은 디버깅을 어렵게 만듭니다.
이를 피하고자 '다시 던지기(rethrowing)' 기술을 사용합니다.
**catch는 알고 있는 에러만 처리하고 나머지는 ‘다시 던져야’ 합니다.**

1. catch가 모든 에러를 받습니다.
2. `catch(err) {...}` 블록 안에서 에러 객체 `err`를 분석합니다.
3. 에러 처리 방법을 알지 못하면 `throw err`를 합니다.

<br>

- 보통 에러 타입을 `instanceof` 명령어로 체크합니다.  
- 기본형 에러는 모두 가지는 `err.name` 프로퍼티로 에러 클래스 이름을 알 수도 있습니다.
- 또는 `err.constructor.name`를 사용할 수도 있습니다.

다시 던진 에러는 `try..catch` "밖으로 던져집니다."
바깥에 `try..catch`가 있다면 여기서 에러를 잡고, 아니면 스크립트는 죽습니다.


```js
function f() {
  try {
    // 에러 발생
  } catch(e) {
    if (e instanceof SyntaxError) {
      // 에러 처리
    } else {
      throw e; // 다시 던지기
    }
  }
}

try {
  f();
} catch (e) {
  // 에러 잡기
}
```

<br><br>

## try…catch…finally

`try..catch`는 `finally`라는 코드 절을 하나 더 가질 수 있는데, 
`finally` 코드는 실행 결과에 상관없이 함수가 실행된 후 항상 실행됩니다.

- 에러가 없는 경우: `try` 실행이 끝난 후 (`return`을 사용해 명시적으로 빠져나는 경우도 마찬가지입니다)
- 에러가 있는 경우: `catch` 실행이 끝난 후

```js
try {
   ... 코드를 실행 ...
} catch(e) {
   ... 에러 핸들링 ...
} finally {
   ... 항상 실행 ...
}
```

<br>

## 💡 `try..catch..finally` 안의 변수는 지역 변수입니다.

<br>

## 💡 `catch`절 없는 `try..finally`

무언가를 측정하는 경우와 같이 끝맺음이 있어야 하는 프로세스에서, 
시작한 프로세스가 마무리되었는지 확실히 하고 싶은 경우에 사용합니다.
`finally` 안에서 스크립트가 죽더라도 완료될 수 있기 때문입니다.
`finally`는 실행 흐름이 함수를 떠나기 전에 실행됩니다.

<br><br>

## 전역 catch

### 🚨 이 절은 코어 자바스크립트가 아닙니다. 호스트 환경을 확인하세요.

`try..catch` 바깥에서 치명적인 에러가 발생해 스크립트가 죽었다고 상상해봅시다.

자바스크립트 명세서에는 이런 치명적인 에러에 대응하는 방법이 없습니다. 하지만 자바스크립트 호스트 환경 대다수는 자체적으로 에러 처리 기능을 제공합니다. Node.js의 `process.on("uncaughtException")`과 브라우저 환경의 `window.onerror`가 그 예입니다. `window.onerror` 프로퍼티에 함수를 할당하면, 예상치 못한 에러가 발생했을 때 이 함수가 실행됩니다.

```js
window.onerror = function(message, url, line, col, error) { .. }
// (에러 메시지, 에러가 발생한 스크립트의 URL, 에러가 발생한 곳의 줄과 열 번호, 에러 객체)
```

그런데 전역 핸들러 `window.onerror`는 죽어버린 스크립트를 복구하려는 목적으로는 잘 사용하지 않고 (프로그래밍 에러가 발생한 경우 `window.onerror`만으로 스크립트를 복구하는 건 사실상 불가능하죠) 개발자에게 에러 메시지를 보내는 용도로 사용합니다.

이외 https://errorception.com 나 http://www.muscula.com같은 에러 로깅 관련 상용 서비스가 여러 가지 있습니다.
이런 서비스들은 다음과 같은 프로세스로 동작합니다.

1. 서비스를 가입하면 자바스크립트 파일(혹은 스크립트 url)을 받는데, 개발자는 이 파일을 페이지에 삽입합니다.
2. 받은 파일은 커스텀 `window.onerror` 함수를 설정합니다.
3. 에러가 발생하면, 이 커스텀 함수가 에러에 관한 내용을 담아 서비스에 네트워크 요청을 보냅니다.
4. 개발자는 서비스 사이트에 로그인해 기록된 에러를 확인합니다.
