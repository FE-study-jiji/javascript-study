### 01 'try..catch'와 에러 핸들링

- `try..catch`는 런타임 에러를 잡아 처리합니다(`parse-time` 에러는 잡지 못함).  
  _자바스크립트 엔진은 코드를 읽고 난 후 실행합니다. 문법이 잘못된 경우 등 코드를 읽는 중에 발생하는 에러는 `parse-time` 에러라 하는데, 엔진이 코드를 이해할 수 없기 때문에 코드 안에서 복구가 불가능합니다. 반대로 유효한 코드에서 발생하는 에러는 `runtime` 에러라 합니다._
- 동기적으로 동작하기 때문에 `setTimeout` 등 스케줄된 코드는 처리할 수 없습니다.
- 에러 객체는 `name`, `message`, `stack` 같은 프로퍼티를 가집니다.
- `catch`문에서 에러 인자를 생략할 수 있습니다.
- `throw` 연산자로 에러를 직접 만들 수 있습니다. 어떤 값이든 가능하나 대개 내장 Error 클래스를 상속받은 에러 객체를 사용합니다.
- 에러 다시 던지기
- `finally`절
- 대부분의 호스트 환경이 ‘전역’ 에러 핸들러(예: 브라우저의 `window.onerror`)를 지원하기 때문에 `try..catch` 바깥에서 발생한 에러도 잡을 수 있습니다. 죽어버린 스크립트를 복구하는 목적으로 사용하기보다 에러 로깅 서비스를 사용할 때 주로 씁니다.


### 02 커스텀 에러와 에러 확장

- 커스텀 에러는 `Error`나 다른 내장 에러 클래스를 상속받아 만들 수 있습니다.   
  이때 `super`를 호출해야 한다는 점과 `name` 프로퍼티를 신경 써야 한다는 점을 잊지 마세요.
- `instanceof`를 사용하면 에러 종류를 판별할 수 있습니다. 상속된 클래스에도 동작하기 때문에 `err.name`을 사용하는 것보다 추천합니다.     
  그런데 서드파티 라이브러리에서 온 에러 객체는 클래스를 알아내는 것이 쉽지 않습니다. 이럴 땐 name 프로퍼티를 사용해 오류 종류를 확인할 수 있습니다.
- **예외 감싸기**   
  에러 종류가 많아짐에 따라 분기문을 추가하기보다, 모든 에러를 포함할 수 있는 추상 에러를 하나 만들어 에러 발생시 이를 던지도록 합니다.  
  필수는 아니지만, 추상 에러를 던질 때 실제 발생한 에러를 추상 에러의 프로퍼티(`err.cause`)로 넘기면 구체적인 에러 정보를 확인할 수 있습니다. 
