```
📍 [요약]
- 재귀 단계, 베이스, 재귀 깊이
- 중첩 호출의 최대 개수는 재귀 깊이 라고 합니다. 
자바스크립트는 재귀 깊이를 제한하며, 만개까지는 허용하지만 대부분 십만까지는 다루지 못합니다.
이런 제한을 완화하기 위해 엔진 내부에서 'tail calls optimization’라는 최적화를 수행하긴 합니다.
- 중첩 함수 호출에서 실행 컨텍스트와 스택
- 재귀를 반복문으로 바꾸는 것이 대게 메모리를 적게 사용하지만, 큰 개선이 없는 케이스도 몇 있고, 재귀가 유지보수에 유리합니다.
```

# 재귀와 스택

함수가 자신을 호출하는 단계를 **재귀 단계(recursion step)** 라고 부릅니다. basis라고도 불리는 재귀의 **베이스(base)** 는 작업을 아주 간단하게 만들어서 함수가 더 이상은 서브 호출을 만들지 않게 해주는 인수입니다.

가장 처음 하는 호출을 포함한 **중첩 호출의 최대 개수는 재귀 깊이(recursion depth)** 라고 합니다.

자바스크립트 엔진은 최대 재귀 깊이를 제한합니다. 
만개 정도까진 확실히 허용하고, 엔진에 따라 이보다 더 허용하기도 합니다. 
하지만 대다수의 엔진이 십만까지는 다루지 못합니다. 
이런 제한을 완화하려고 **엔진 내부에서 자동으로 'tail calls optimization’라는 최적화를 수행**하긴 하지만, 모든 곳에 적용되는 것은 아니고 간단한 경우에만 적용됩니다.

<br>

## 실행 컨텍스트와 스택

실행 중인 함수의 실행 절차에 대한 정보는 해당 함수의 실행 컨텍스트(execution context) 에 저장됩니다.

실행 컨텍스트는 함수 실행에 대한 세부 정보를 담고 있는 내부 데이터 구조입니다. 
제어 흐름의 현재 위치, 변수의 현재 값, this의 값 등이 저장됩니다.
한 번의 함수 호출 당 하나의 실행 컨텍스트가 생성됩니다.

함수 내부에서 중첩 호출이 일어나면

* 현재 함수의 실행이 일시 중지되고,
* **중지된 함수의 실행 컨텍스트는 실행 컨텍스트 스택(execution context stack)** 이라는 특별한 자료 구조 최상단에 저장됩니다.
* 중첩 호출을 위한 새로운 컨텍스트가 만들어지고, 실행됩니다. 실행이 끝나면 실행 컨텍스트는 메모리에서 삭제됩니다.
* 실행 컨텍스트 스택에서 중단했던 함수의 실행 컨텍스트를 꺼내오고, 다시 이어갑니다.

<br>

재귀는 반복문으로 다시 작성할 수 있고, 보통 후자가 함수 호출 비용(메모리 사용)이 적습니다.
하지만 큰 개선이 없는 경우도 있습니다. 
예를 들어, 조건에 따라 함수가 다른 재귀 서브 호출을 하고 그 결과를 합칠 때입니다.
분기문이 복잡하게 얽혀있을 때도 메모리가 크게 절약되지 않습니다.
또한 재귀를 사용한 코드가 짧고 유지보수에도 좋습니다.
