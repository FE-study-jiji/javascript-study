# 오래된 var

```
오래된 스크립트를 읽는 데만 참고하고, 새로운 코드를 작성할 땐 이 방법을 쓰시면 안 됩니다.
```

`var`는 `let`과 유사해서 대부분의 경우 `let`과 `var`를 바꿔도 큰 문제가 없습니다.
하지만 `var`는 초기 자바스크립트 구현 방식 때문에 `let`/`const`과는 다른 방식으로 동작합니다.

<br>

## var는 블록 스코프가 없습니다.

`var` 변수의 스코프는 함수 스코프이거나 전역 스코프입니다. 코드 블록은 관통합니다.
아주 오래전의 자바스크립트에선 블록 수준 렉시컬 환경이 만들어 지지 않았기 때문입니다.

<br>

## var는 변수의 중복 선언을 허용합니다

이미 선언된 변수에 `var`를 사용하면 두 번째 선언문은 무시되고, 값만 갱신됩니다.

## 선언하기 전 사용할 수 있는 var

var 선언은 함수가 시작될 때 (전역 변수라면 스크립트가 시작될 때) 처리됩니다
(단, 변수가 중첩 함수 내에서 정의되지 않아야 이 규칙이 적용됩니다).
이렇게 변수가 끌어올려 지는 현상을 **'호이스팅(hoisting)'** 이라고 부릅니다.
`var`는 함수의 최상위로 ‘끌어 올려집니다(hoisted)’.

아래 예제에서 `if (false)` 블록 안 코드는 절대 실행되지 않지만, 그래도 `phase`는 호이스팅됩니다.

```javascript
function sayHi() {
  phrase = "Hello";

  if (false) {
    var phrase;
  }

  alert(phrase);
}
```

**선언은 호이스팅 되지만 할당은 호이스팅 되지 않습니다.**
변수에 할당하기 전까진 값이 `undefined`이죠.

<br>

## 즉시 실행 함수 표현식

과거에 `var`만 있었을 때 개발자들은 블록 레벨 스코프를 가질 수 있게 여러 방안을 고민했습니다.
이때 만들어진 것이 **'즉시 실행 함수 표현식(`IIFE`, immediately-invoked function expressions)'** 입니다.
요즘엔 자주 쓰지 않습니다.

```javascript
// IIFE를 만드는 방법

(function() {
  alert("함수를 괄호로 둘러싸기");
})();

(function() {
  alert("전체를 괄호로 둘러싸기");
}());

!function() {
  alert("표현식 앞에 비트 NOT 연산자 붙이기");
}();

+function() {
  alert("표현식 앞에 단항 덧셈 연산자 붙이기");
}();
```

위 방법 없이 `function(){}()`로 작성하면 에러가 발생합니다 
(함수 선언문엔 함수 이름이 반드시 있어야 하고, 함수 선언문은 정의와 동시에 호출하는 것을 허용하지 않기 때문입니다.
IIFE 방법을 사용하면 함수 선언문이 아닌 표현식으로 인식하도록 속일 수 있습니다).
