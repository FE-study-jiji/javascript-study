

# 변수의 유효범위와 클로저

자바스크립트는 함수 지향 언어입니다. 이는 개발자에게 많은 자유를 줍니다.
함수를 동적으로 생성할 수 있고, 생성한 함수를 다른 함수에 인수로 넘길 수 있으며, 생성된 곳이 아닌 곳에서 함수를 호출할 수도 있기 때문입니다.

앞서 함수 내부에서 외부 변수에 접근할 수 있다고 배웠는데, 
함수가 생성된 이후에 외부 변수가 변경되면 어떤 일이 발생할까요?
이와 관련된 여러 시나리오들을 다뤄봅시다.
참고로, 여기선 `let`, `const`로 선언한 변수만 다룹니다.

<br>

## 코드 블록

코드 블록 `{...}` 안에서 선언한 변수는 블록 안에서만 사용할 수 있습니다.

<br>

## 중첩 함수

함수 내부에서 선언한 함수는 **‘중첩(nested)’ 함수**라고 부릅니다. 자바스크립트에서 흔히 사용됩니다.
중첩 함수는 새로운 객체의 프로퍼티 형태나 중첩 함수 그 자체로 반환될 수 있습니다.
이렇게 반환된 중첩 함수는 어디서든 호출해 사용할 수 있습니다. 물론 이때도 외부 변수에 접근할 수 있다는 사실은 변함없습니다.

```javascript
function makeCounter() {
  let count = 0;
  
  return function() {
    return count++;
  };
}

let counter = makeCounter();
counter();
```

그런데 "`counter`를 여러 개 만들었을 때, 이 함수들은 서로 독립적일까? 
함수와 중첩 함수 내 `count` 변수엔 어떤 값이 할당될까?” 같은 의문이 들기 마련입니다.

<br>

## 렉시컬 환경

```
여기부터 다룰 내용은 굉장히 어렵습니다! 단계를 나눠 진행하겠습니다.
```

### 단계 1. 변수

자바스크립트에선 **실행 중인 함수, 코드 블록 `{...}`, 스크립트 전체는 렉시컬 환경(Lexical Environment) 이라 불리는 내부 숨김 연관 객체(internal hidden associated object)를 갖습니다**.
렉시컬 환경 객체는 두 부분으로 구성됩니다.

1. **환경 레코드(Environment Record)** – 모든 지역 변수를 프로퍼티로 저장하고 있는 객체입니다. `this` 값과 같은 기타 정보도 여기 저장됩니다.
2. **외부 렉시컬 환경(Outer Lexical Environment) 에 대한 참조** – 외부 코드와 연관됨

우리가 '변수'라고 하는 것은 **사실 특수 내부 객체인 `환경 레코드`의 프로퍼티일 뿐입니다.**
'변수를 가져오거나 변경’하는 것은 '환경 레코드의 프로퍼티를 가져오거나 변경’함을 의미합니다.

<br>

먼저, 스크립트 전체와 관련된 렉시컬 환경은 **전역 렉시컬 환경(global Lexical Environment)** 이라고 합니다.

![image](https://user-images.githubusercontent.com/65887537/194593031-2047dcad-4d01-4814-ae34-b15b04728bca.png)

위 그림에서 네모 상자는 환경 레코드, 화살표는 외부 렉시컬 환경에 대한 참조를 나타냅니다. 
전역 렉시컬 환경은 외부 참조를 갖지 않기 때문에 화살표가 `null`을 가리킵니다.

![image](https://user-images.githubusercontent.com/65887537/194593290-88581829-beb3-465f-bd11-527400736b45.png)

코드가 한 줄, 한 줄 실행될 때마다 전역 렉시컬 환경이 위와 같이 변화합니다.

1. 스크립트가 시작되면 스크립트 내에서 선언한 변수 전체가 렉시컬 환경에 올라갑니다(pre-populated). <br>
   이때 변수의 상태는 특수 내부 상태(special internal state)인 `uninitialized`가 됩니다. 자바스크립트 엔진은 uninitialized 상태의 변수를 인지하긴 하지만, `let`을 만나기 전까진 이 변수를 참조할 수 없습니다.
3. `let`이 나타났으니 이제 `phase` 변수를 사용할 수 있습니다. 아직 값을 할당하기 전이기 때문에 `undefined`입니다.
4. `phrase`에 값이 할당되었습니다.
5. `phrase`의 값이 변경되었습니다.

<br>

렉시컬 환경은 명세서에만 존재하는 '이론상의' 객체입니다.
따라서 코드를 사용해 직접 렉시컬 환경을 얻거나 조작하는 것은 불가능합니다.

자바스크립트 엔진들은 명세서에 언급된 사항을 준수하면서 엔진 고유의 방법을 사용해 렉시컬 환경을 최적화합니다. 
사용하지 않는 변수를 버려 메모리를 절약하거나 다양한 내부 트릭을 써서 말이죠.

<br>

### 단계 2. 함수 선언문

함수도 값입니다.
다만 **함수 선언문(function declaration)** 으로 선언한 함수는 일반 변수와는 달리 **바로 초기화됩니다**.
(주의: 함수 표현식은 해당하지 않습니다.)
따라서 렉시컬 환경이 만들어지는 즉시 사용할 수 있습니다. 선언되기 전에도 말입니다.

![image](https://user-images.githubusercontent.com/65887537/194692704-02b6ca3c-44b0-4a05-a422-8093ed26a6aa.png)

<br>

### 단계 3. 내부와 외부 렉시컬 환경

**함수를 호출해 실행하면 새로운 렉시컬 환경**이 자동으로 만들어집니다. 
여기에 함수 호출 시 넘겨받은 매개변수와 함수의 지역 변수가 저장됩니다.

![image](https://user-images.githubusercontent.com/65887537/194692784-33f42df0-52eb-4f9c-8a8b-0830ef0fb4ab.png)

함수 호출 중에는 해당 함수를 위한 내부 렉시컬 환경과 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경을 갖게 됩니다.
코드에서 변수에 접근할 땐, **먼저 내부 렉시컬 환경에서 찾습니다.** 변수를 찾지 못하면 검색 범위를 내부 렉시컬 환경이 참조하는 **외부 렉시컬 환경으로 확장합니다**. 검색 범위가 전역 렉시컬 환경으로 확장될 때까지 반복됩니다.

전역 렉시컬 환경에 도달할 때까지 변수를 찾지 못하면 **엄격 모드에선 에러가 발생**합니다.
비 엄격 모드에선 정의되지 않은 변수에 값을 할당하면 에러가 발생하는 대신 새로운 전역 변수가 만들어지는데, 이는 하위 호환성을 위해 남아있는 기능입니다.

<br>

### 단계 4. 함수를 반환하는 함수

`makeCoutner` 예시로 돌아가 봅시다.

이전까지 예시와 달리, 실행되는 도중에 중첩 함수가 만들어집니다. 
**여기서 중요한 사실이 하나 있습니다. 모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억합니다.** 
함수는 [[Environment]]라 불리는 **숨김 프로퍼티**를 갖는데, 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장됩니다.
[[Environment]]는 함수가 **생성될 때 딱 한 번 값이 세팅되고 영원히 변하지 않습니다.**
호출 장소와 상관없이 함수가 자신이 태어난 곳을 기억할 수 있는 것이 이 때문입니다. 

예제에서 `counter()`를 호출할 때마다 새로운 렉시컬 환경이 생성되고,
`counter.[[Environment]]`엔 `{count: 0}` 이 있는 렉시컬 환경에 대한 참조가 저장됩니다. 
이제 `count++`가 실행되는데, **변숫값 갱신은 변수가 저장된 렉시컬 환경에서 이뤄집니다.**

![image](https://user-images.githubusercontent.com/65887537/194694289-7336516c-4dc8-4de9-8404-5a472951a7fd.png)

<br>

### 클로저

클로저는 **외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수**를 의미합니다. 

몇몇 언어에선 클로저를 구현하는 게 어렵거나 불가능하지만, 자바스크립트에선 **모든** 함수가 자연스럽게 클로저가 됩니다. 
(예외가 하나 있긴 한데 자세한 내용은 `new Function` 문법에서 다루도록 하겠습니다.)

<br>

## 가비지 컬렉션









