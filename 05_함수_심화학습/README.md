# 05 함수 심화학습


### 07 new Function 문법
- `new Function ([arg1, arg2, ...argN], functionBody)` 문법으로도 함수를 만들 수 있습니다.
- 런타임에 받은 문자열을 사용해 함수를 만듭니다.
- 이렇게 만든 함수의 `[[Environment]]` 프로퍼티는 전역 렉시컬 환경을 참조합니다.
  압축기(minifier) 때문에 생길 수 있는 문제를 예방하기 위해서입니다.

### 08 setTimeout과 setInterval을 이용한 호출 스케줄링
- `setTimeout`으로 일정 시간이 지난 후에 함수를 실행할 수 있습니다.  
  `clearTimeout(타이머 식별자)`로 취소할 수 있습니다.
- `setInterval`로 시간 간격을 두고 함수를 실행할 수 있습니다.  
  `clearInterval(타이머 식별자)`로 중단할 수 있습니다.
- 중첩 `setTimeout`으로도 일정 간격을 두고 실행할 수 있습니다.
  더 유연하고, (대개) 지연 간격을 보장한다는 장점이 있다.
- 둘에게 넘긴 함수는 완료시까지 가비지 컬렉션의 대상이 되지 않기 때문에, 스케줄링할 필요가 없어진 함수는 아무리 작더라도 취소하도록 합니다.
- 브라우저 환경에서 실제 대기 시간은 0이 아닙니다.

### 09 call, apply와 데코레이터, 포워딩
- 인수로 받은 함수를 감싸 기능을 추가하는 함수를 데코레이터라고 합니다.
- 이를 객체 메서드에 사용하려면 `f.call()`로 `this`를 고정해주어야 합니다.
- 좀 더 빠른 `f.apply()`를 사용할 수도 있습니다.
  이처럼 컨텍스트와 함께 인수 전체를 다른 함수에 전달하는 것을 콜 포워딩이라고 합니다.
- 메서드 빌리기
- 함수에 프로퍼티가 있는 경우엔 데코레이터 사용에 주의해야 합니다. 이후 배울 `Proxy`가 필요합니다.

### 10 함수 바인딩
- 객체 메서드가 객체 내부가 아닌 다른 곳에 전달되어 호출될 때 `this` 정보가 사라지는 문제가 있습니다.
- 해결 방법 1) 래퍼 함수를 사용합니다. 취약점이 있습니다.
- 해결 방법 2) `bind`를 사용해 컨텍스트를 바인딩합니다.
- `this`뿐만 아니라 인수도 바인딩 가능합니다. 인수 일부를 고정한 함수를 부분 적용 함수라 부릅니다.

