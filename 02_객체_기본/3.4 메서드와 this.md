```
📍 [요약]
- 객체 프로퍼티에 할당된 함수를 메서드라고 합니다.
- 메서드는 this로 객체를 참조합니다. 자바스크립트의 this 값은 여타 언어들과 달리 런타임에 결정됩니다.
- 화살표 함수는 일반 함수와 달리 외부 일반 함수에서 this 값을 가져옵니다.
```
```
💡 this 값이 헷갈릴 때 참고하면 좋은 가장 명쾌한 규칙 by Arnav Aggrawal
1. 함수를 호출할 때 new 키워드를 사용하는 경우, 함수 내부에 있는 this는 완전히 새로운 객체입니다.
2. apply, call, bind가 함수의 호출/생성에 사용되는 경우, 함수 내의 this는 인수로 전달된 객체입니다.
3. obj.method()와 같이 함수를 메서드로 호출하는 경우, this는 함수가 프로퍼티인 객체입니다.
4. 함수가 위 조건 없이, 즉, 자유함수로 호출되는 경우 this는 전역 객체입니다. 
   브라우저에서는 window 객체, 엄격 모드라면 undefined입니다.
5. 위의 규칙 중 다수가 적용되면 더 상위 규칙이 승리합니다.
6. 함수가 ES2015 화살표 함수인 경우 위의 모든 규칙을 무시하고 생성된 시점에서 주변 스코프의 this값을 받습니다.
```

# 메서드와 this

## 메서드 만들기
객체 프로퍼티에 할당된 함수를 메서드(method) 라고 부릅니다.

```javascript
user = {
  sayHi: function() {
    alert("Hello");
  }
};
```

참고) 객체를 사용하여 개체를 표현하는 방식을 객체 지향 프로그래밍(OOP)라 합니다.
그 자체만으로도 학문의 분야를 만드는 중요한 주제입니다. 
관련 추천도서로는 에릭 감마의 ‘GoF의 디자인 패턴’, 그래디 부치의 ‘UML을 활용한 객체지향 분석 설계’ 등이 있습니다.

### 메서드 단축 구문
객체 리터럴 안에 메서드를 선언할 때 `function`을 생략한 단축 문법을 사용할 수 있습니다.
(단, 두 방법간 객체 상속과 관련된 **미묘한 차이**가 존재합니다.)

```javascript
user = {
  sayHi() { // "sayHi: function()"과 동일합니다.
    alert("Hello");
  }
};
```

## 메서드와 this
메서드 내부에서 this 키워드를 사용해 객체에 접근할 수 있습니다.

```javascript
let user = {
  name: "John",
  sayHi() {
    alert(this.name); // 'this'는 '현재 객체'입니다.
  }
};
```

this를 사용하지 않고 외부 변수를 참조해 객체에 접근하는 것도 가능은 합니다만, 예상치 못한 에러가 발생할 수 있습니다. 
다음 예제에서 `user`를 복사해 다른 변수에 할당하고, user를 전혀 다른 값으로 덮어썼을 때, `sayHi`는 원치않는 값(**null**)을 참조해
"Error: Cannot read property 'name' of null" 에러를 냅니다.

```javascript
let user = {
  name: "John",
  sayHi() {
    alert(user.name); // 'this' 대신 'user'를 이용함
  }
};
```

## 자유로운 this
다른 대부분의 언어에서 `this`는 항상 메서드가 정의된 객체를 참조합니다. **이런 개념을 'bound this'라 합니다**.

자바스크립트의 this는 동작 방식이 다릅니다. 
값이 **런타임에 결정되어,** 함수가 호출되기 전까지 this엔 값이 할당되지 않습니다.

또한 정의된 위치에 상관없이 '점 앞의' 객체에 따라 달라집니다. 즉, 동일 함수도 다른 객체가 호출하면 this값이 달라집니다.

심지어 객체가 없어도 호출할 수 있습니다. 
이 때, 엄격 모드라면 this 값은 `undefined`가 되고, 엄격 모드가 아니라면 전역 객체를 참조합니다(브라우저 환경에선 `window` 전역 객체).
이런 동작 차이는 엄격 모드가 도입된 배경이기도 합니다.

**모든 함수에 this를 사용**할 수 있습니다.

함수를 복사해 객체 간 전달할 수 있습니다.

런타임에 결정되기 때문에 하나의 함수로 여러 객체에서 재사용할 수 있다는 장점도 있지만,
실수로 이어질 수 있다는 단점도 있습니다.

## this가 없는 화살표 함수
화살표 함수는 일반 함수와는 달리 ‘고유한’ this를 가지지 않습니다.
화살표 함수에서 this를 참조하면, **화살표 함수가 아닌 ‘평범한’ 외부 함수에서 this 값을 가져옵니다.**
별개의 this가 만들어지는 건 원하지 않고, 외부 컨텍스트에 있는 this를 이용하고 싶은 경우 유용합니다.

```javascript
let user = {
  firstName: "보라",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow(); // arrow()의 this는 외부 함수 user.sayHi()의 this가 됩니다.
  }
};
```
