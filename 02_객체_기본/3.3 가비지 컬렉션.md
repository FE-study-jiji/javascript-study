```
📍 [요약]
- 자바스크립트 엔진 내에선 가비지 컬렉터가 끊임없이 도달 불가능한 객체를 메모리에서 삭제합니다.
- 도달 가능한 값을 "루트"라고 부릅니다.
- 가비지 컬렉션 기본 알고리즘은 'mark-and-sweep'이며, 다양한 최적화 기법이 있습니다.
```

# 가비지 컬렉션
자바스크립트는 눈에 보이지 않는 곳에서 메모리 관리를 수행합니다. 
**자바스크립트 엔진 내에선 가비지 컬렉터(garbage collector)** 가 끊임없이 동작하며 모든 객체를 모니터링하고,
더는 쓸모 없어지게 된 것들을 찾아내 메모리에서 삭제합니다.

엔진이 자동으로 수행하므로 개발자는 이를 억지로 실행하거나 막을 수 없습니다.

## 가비지 컬렉션 기준
자바스크립트는 **도달 가능성(reachability)** 이라는 개념을 사용해 메모리를 관리합니다. 
도달 가능한 값은 어떻게든 접근하거나 사용할 수 있는 값을 의미하며, 삭제되지 않습니다. 예를 들어,

* 현재 함수의 지역 변수와 매개변수
* 중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수
* 전역 변수

등등입니다. 이런 값은 **루트(root)** 라고 부릅니다. 그리고 다음 항목 또한 도달 가능한 값이 됩니다.

* 루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값

![image](https://user-images.githubusercontent.com/65887537/192458229-9663b820-3c00-46a8-9cdd-d6273de67d32.png)

## 간단한 예시
-생략-

## 참조 두 개
-생략-

## 연결된 객체
-생략-

## 도달할 수 없는 섬
-생략-

## 내부 알고리즘
가비지 컬렉션 기본 알고리즘은 **'mark-and-sweep’** 입니다. 대게 다음 단계를 거쳐 수행됩니다.

1. 가비지 컬렉터는 루트(root) 정보를 수집하고 이를 mark(기억) 합니다.
2. 루트가 참조하고 있는 모든 객체를 방문하고 이것들을 mark 합니다.
3. mark 된 모든 객체에 방문하고 그 객체들이 참조하는 객체도 mark 합니다.<br>
   한번 방문한 객체는 전부 mark 하기 때문에 같은 객체를 다시 방문하는 일은 없습니다.
5. 루트에서 도달 가능한 모든 객체를 방문할 때까지 위 과정을 반복합니다.
6. mark 되지 않은 모든 객체를 메모리에서 삭제합니다.

자바스크립트 엔진은 가비지 컬렉션을 더 빠르게 하는 다양한 최적화 기법을 적용합니다.

(참고로, 엔진마다 세부 사항이나 기법이 다르고 엔진이 발전하며 기법도 달라지기 때문에 [심화 학습](https://ko.javascript.info/garbage-collection#:~:text=%EB%AA%A8%EB%8D%98%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EC%97%94%EC%A7%84%EC%9D%80,%EA%B2%83%EC%9D%84%20%EC%B6%94%EC%B2%9C%ED%95%B4%20%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4.)은 그리 가치있지 않다 생각합니다)

* **generational collection(세대별 수집)**

  객체의 상당수는 생성 이후 제 역할을 빠르게 수행하고 금방 쓸모가 없어집니다. 이런 객체를 '새로운 객체'로 구분해 공격적으로 메모리에서 제거합니다.
  일정 시간 이상 살아남은 객체는 '오래된 객체’로 분류하고, 덜 감시합니다.
* **incremental collection(점진적 수집)**
  
  방문해야 할 객체가 많다면 모두 한 번에 방문하고 mark하는데 시간이 많이 걸리고 리소스가 많이 사용됩니다.
  따라서 가비지 컬렉션을 여러 부분으로 분리한 다음, 각 부분을 별도로 수행합니다.
  추가 작업이 필요하지만, 긴 지연을 짧은 지연 여러 개로 분산시킬 수 있다는 장점이 있습니다.
* **idle-time collection(유휴 시간 수집)**

  실행에 주는 영향을 최소화하기 위해 CPU가 유휴 상태일 때에만 가비지 컬렉션을 실행합니다.
