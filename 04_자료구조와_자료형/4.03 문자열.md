# 문자열

페이지 인코딩 방식과 상관없이 항상 `UTF-16` 형식을 따릅니다.

<br>

## 따옴표

`'`, `"`, ` 를 사용할 수 있습니다. 
백틱엔 특별한 기능이 있는데, 여러 줄로 작성하거나, 표현식을 ${…}로 감싸고 문자열 중간에 삽입할 수 있습니다.
후자를 템플릿 리터럴(template literal)이라고 부릅니다.

자주 사용되진 않지만, 백틱은 '템플릿 함수(template function)'에서도 사용됩니다.
func\`string\` 같이 백틱 앞에 함수 이름(`func`)을 써주면, 
이 함수는 백틱 안의 문자열이나 표현식 평가 결과를 인수로 받아 자동으로 호출됩니다.
이를 '태그드 템플릿(tagged template)'이라 부릅니다.

<br>

## 특수 기호

이스케이프 문자 역슬래시 `\`로 시작합니다.
역슬래시 `\`는 문자열을 정확하게 읽는 역할이 끝나면 사라집니다. 즉, 메모리에 저장되는 문자열엔 `\`가 없습니다.

|특수 문자|설명|
|------|---|
|\n|줄 바꿈|
|\r|Windows에선 캐리지 리턴과 줄 바꿈 특수 문자를 조합(\r\n)해 줄을 바꿉니다. |
|\\', \\"||
|\t||
|\xXX|16진수로 표현한 유니코드 글자|
|\uXXXX|UTF-16 인코딩 규칙을 사용하는 16진수 코드로 표현한 유니코드 기호|
|\u{X…XXXXXX}|UTF-32로 표현한 유니코드 기호|

<br>

## 문자열의 길이

`length` 프로퍼티에 저장됩니다. `\n`은 문자 하나로 취급됩니다. 

<br>

## 특정 글자에 접근하기

* `str[pos]` : 위치에 글자가 없는 경우 `undefined` 반환.
* `str.chatAt(pos)` : 위치에 글자가 없는 경우 빈 문자열 반환 (하위 호환성을 위해 남아있는 메서드입니다)

<br>

## 문자열의 불변성

문자열은 수정할 수 없습니다. 새로운 문자열을 만들어 변수에 할당해야 합니다.

<br>

## 대·소문자 변경하기

* `toLowerCase()`
* `toUpperCase()`

글자 하나만 변경하는 것도 가능합니다. `'String'[0].toLowerCase()`

<br>

## 부분 문자열 찾기

* `str.indexOf(substr[, pos])` : pos부터 부분 문자열의 위치를 찾아 반환. 없으면 `-1` 반환.
* `str.lastIndexOf(substr[, pos])`

```javascript
let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( `위치: ${pos}` );
}
```

* `~str.indexOf(substr)`  
  이 방법은 오래 전에 자주 사용된, 비트(bitwise) NOT 연산자 ~를 사용해 '부분 문자열인지 확인'하는 코드입니다.
  `~` 연산자는 피연산자를 32비트 정수로 바꾼 후(소수부는 모두 버려짐) 모든 비트를 반전합니다. 즉, `~n` 는 `-(n+1)`이 됩니다.
  부호가 있는 32비트 정수 n 중, ~n을 0으로 만드는 경우는 n == -1일 때가 유일합니다.
  이를 이용해 `-1`를 반환하지 않는 경우를 짧은 구문으로 찾을 수 있습니다.
  
  단, 아주 큰 숫자에 ~ 연산자를 적용하면 32비트 정수로 바꾸는 과정에서 잘림 현상이 발생해 0을 반환할 수 있습니다.
  문자열이 아주 길지 않은 경우에만 의도한 대로 작동한다는 점을 기억하기 바랍니다.
  
* `str.includes(substr[, pos])`  
  위치 정보는 필요하지 않고 포함 여부만 알고 싶을 때 적합한 메서드입니다.

* `startsWith, endsWith` : 특정 문자열로 시작/끝나는지 확인합니다.

<br>

## 부분 문자열 추출하기

(세 메서드 중 `slice`만 사용해도 충분할 것 같습니다.)

* `str.slice(start [, end])` : start부터 end 전까지를 반환. start, end가 음수면 끝에서부터 카운팅을 시작합니다.
* `str.substring(start [, end])` : start와 end "사이" 문자열을 반환. start가 end보다 커도 괜찮습니다. 음수는 0으로 처리됩니다.
* `str.substr(start [, length])` : start에서부터 length 개의 글자를 반환. start가 음수면 뒤에서부터 개수를 셉니다.

<br>

## 문자열 비교하기

문자열은 UTF-16 순서를 기준으로 비교됩니다.

모든 문자열은 글자와 숫자 형식의 코드를 매칭한 UTF-16을 사용해 인코딩됩니다.
`str.codePointAt(pos)`로 글자의 코드를 반환하거나 `String.fromCodePoint(code)`로 코드에 대응하는 글자를 만들 수 있습니다.
또한 `\u` 뒤에 16진수 코드를 붙이는 방식으로도 글자를 만들 수 있습니다.

코드 `65`~`220` 을 출력해보면, 대문자 `알파벳 < 특수문자 < 소문자 알파벳 < `Ö` 등의 특수기호` 순입니다. 따라서,

* 소문자는 대문자보다 항상 큽니다.
* 발음 구별 기호(diacritical mark)가 붙은 문자는 알파벳 순서 기준을 따르지 않습니다. (예: `Ö`)


<br>

### 문자열 제대로 비교하기

문자열을 정확히 비교하려면 페이지에서 어떤 언어를 사용하고 있는지 브라우저가 알아야 합니다.
다행히도 모던 브라우저 대부분이 국제화 관련 표준인 ECMA-402를 지원합니다(IE10은 아쉽게도 Intl.js 라이브러리를 사용해야 합니다).

**ECMA-402**엔 언어가 다를 때 적용할 수 있는 문자열 비교 규칙과 이를 준수하는 메서드가 정의되어있습니다.
`str.localeCompare(str2[, locales, options])`를 호출하면 ECMA-402 규칙에 따라 `str`이 `str2`보다 작은지, 같은지, 큰지를 나타내주는 정수가 반환됩니다.
(작으면 음수, 크면 양수, 같으면 0)

<br>

## 문자열 심화

### 서로게이트 쌍

자주 사용되는 글자들은 모두 2바이트 코드를 가지고 있습니다. 
그런데 2바이트는 현존하는 모든 기호를 표현하기에 부족합니다.
이를 극복하기 위해 사용 빈도가 낮은 기호는 '서로게이트 쌍(surrogate pair)'이라 불리는 2바이트 글자들의 쌍을 사용해 인코딩합니다.

서로게이트 쌍을 사용해 인코딩한 기호의 길이는 2입니다.

`String.fromCodePoint`와 `str.codePointAt` 메서드를 사용할 수 있습니다.

서로게이트 쌍을 구성하는 글자들은 붙어있을 때만 의미가 있습니다. 예를 들어, `'𝒳'[0]` 는 이상한 기호가 출력됩니다.
첫번째 코드는 `0xd800..0xdbff` 사이에, 두번째 코드는 `0xdc00..0xdfff` 사이에 있어야 합니다.

<br>

### 발음 구별 기호와 유니코드 정규화

`àáâäãåā`와 같은 '합성' 글자는 그 수가 너무 많아 UTF-16 테이블에서 독자적인 코드가 없는 것들도 일부 있습니다.
UTF-16에선 몇 개의 유니코드를 남겨, 베이스 글자 뒤에 하나 혹은 여러 개의 유니코드 문자를 붙여 베이스 글자를 꾸밀 수 있도록 합니다.
(예: `S`에 윗점을 나타내는 유니코드`\u0307`을 붙이면, `S\u0307` 가 `Ṡ`가 됩니다)

조합의 순서 등이 달라, 같은 기호이지만 일치하지 않는다고 뜨는 경우가 있습니다.
이를 해결하기 위해 `str.normalize()`로 '유니코드 정규화(unicode normalization)' 알고리즘을 적용합니다.
