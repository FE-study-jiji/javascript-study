# 배열

## 배열 선언

```javascript
let arr = new Array();
let arr = [];
```

<br>

## pop·push와 shift·unshift

* push – 배열 끝에 요소를 추가합니다.
* pop – 배열 끝 요소를 추출합니다.
* shift – 배열 앞 (여러 개의) 요소를 제거하고 나머지 요소를 이동한 후, 제거한 요소를 반환합니다.
* unshift - 배열 앞에 요소를 이동한 후, (여러 개의) 새로운 요소를 추가합니다.

이렇게 처음/끝에 요소를 삽입/삭제하는 연산을 제공하는 자료구조를 컴퓨터 과학 분야에선 데큐(deque, Double Ended Queue)라고 부릅니다.

<br>

## 배열의 내부 동작 원리

배열을 배열답게 만들어주는 것은 특수 내부 표현방식입니다. 
자바스크립트 엔진은 배열의 요소를 인접한 메모리 공간에 차례로 저장해 연산 속도를 높이고,
배열 연산을 더 빠르게 해주는 다양한 최적화 기법을 적용합니다.

그런데 개발자가 배열을 일반 객체처럼 다루면 이런 기법들이 제대로 동작하지 않습니다.
배열의 본질은 객체이기 때문에 `array.age = 5` 처럼 원하는 프로퍼티를 추가해도 문제가 발생하지 않습니다.
그러나 자바스크립트 엔진의 배열 최적화 기법이 동작하지 않습니다.

잘못된 방법의 예는 다음과 같습니다.

* `arr.test = 5` 같이 숫자가 아닌 값을 프로퍼티 키로 사용하는 경우
* `arr[0]`과 `arr[1000]`만 추가하고 그 **사이에 아무런 요소도 없는 경우*
* `arr[1000]`, `arr[999]`같이 요소를 **역순으로 채우는 경우**

<br>

## 성능
(생략)

<br>

## 반복문

* `for (let i = 0; i < arr.length; i++)`
* `for .. of`
* `for .. in`

단, `for .. in`은 다음과 같은 특징으로 문제가 발생합니다.

*  **모든 프로퍼티를 대상**으로 순회합니다. 키가 숫자가 아닌 프로퍼티도 포함됩니다. 
 ‘유사 배열(array-like)’ 객체에서 키가 숫자형이 아닌 프로퍼티와 메서드도 순회하기 때문에 문제를 일으킬 수 있습니다.
 * 객체와 함께 사용할 때 최적화되어 있어서 배열에 사용하면 **10~100배 정도 느립니다**.
 대체로 빠른 편이지만, 병목 지점에서는 문제가 되긴 합니다.
 
 <br>
 
 ## ‘length’ 프로퍼티

`length` 프로퍼티는 배열 내 요소의 개수가 아니라 가장 큰 인덱스에 1을 더한 값입니다. 
배열에 조작을 가하면 자동으로 갱신됩니다. 
`arr.length = 2` 처럼 수동으로 조작할 수도 있습니다. 값을 감소시키면 배열이 잘리고, 다시 되돌릴 수 없습니다.

<br>

## new Array()

`new Array(n)`으로 만든 배열의 요소는 모두 `undefined`로, 비어있습니다. 이런 상황을 피하기 위해 대부분 대괄호를 사용합니다.

<br>

## 다차원 배열

(생략)

<br>

## toString

요소를 쉼표로 구분한 문자열을 반환합니다.

배열엔 `Symbol.toPrimitive`나 `valueOf` 메서드가 없어 아래 예시처럼 문자열로의 형 변환이 일어납니다.

```javascript
alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
```
