```
📍 [요약]
- 위크맵
  - 맵과 유사한 컬렉션
  - 위크맵을 구성하는 요소의 키는 오직 객체만 가능합니다. 
  - 키로 사용된 객체가 메모리에서 삭제되면 이에 대응하는 값 역시 삭제됩니다.
- 위크셋
  - 셋과 유사한 컬렉션
  - 위크셋엔 객체만 저장할 수 있습니다. 
  - 위크셋에 저장된 객체가 도달 불가능한 상태가 되면 해당 객체는 메모리에서 삭제됩니다.
- 두 자료구조 모두 구성 요소 전체를 대상으로 하는 메서드를 지원하지 않습니다. 구성 요소 하나를 대상으로 하는 메서드만 지원합니다.

- 객체엔 ‘주요’ 자료를, 위크맵과 위크셋엔 ‘부수적인’ 자료를 저장하는 형태로 위크맵과 위크셋을 활용할 수 있습니다. 
  객체가 메모리에서 삭제되면, 
  (그리고 오로지 위크맵과 위크셋의 키만 해당 객체를 참조하고 있다면) 위크맵이나 위크셋에 저장된 연관 자료들 역시 메모리에서 자동으로 삭제됩니다.
```
<br/>

# 배경
가비지 컬렉션에서 배웠듯이 자바스크립트 엔진은 도달 가능한 (그리고 추후 사용될 가능성이 있는) 값을 메모리에 유지합니다.   
자료구조를 구성하는 요소도 자신이 속한 자료구조가 메모리에 남아있는 동안 대개 도달 가능한 값으로 취급되어 메모리에서 삭제되지 않습니다.   
객체의 프로퍼티나 배열의 요소, 맵이나 셋을 구성하는 요소들이 이에 해당합니다.  
```js
let john = { name: "John" };

let map = new Map();
map.set(john, "...");

john = null; // 참조를 null로 덮어씀

// john을 나타내는 객체는 맵 안에 저장되어있습니다.
for(let obj of map.keys()){
  alert(JSON.stringify(obj));      // {"name":"John"}
}
alert(map.size);      // 1
```
<br/>

이런 관점에서 `위크맵(WeakMap)`은 일반 맵과 전혀 다른 양상을 보입니다.   
### 위크맵을 사용하면 키로 쓰인 객체가 가비지 컬렉션의 대상이 됩니다.

<br/>

# 위크맵(WeakMap)
`맵`과 `위크맵`의 첫 번째 차이는 `위크맵`의 키가 반드시 객체여야 한다는 점입니다.   
`위크맵`의 키로 사용된 객체를 참조하는 것이 아무것도 없다면 해당 객체는 메모리와 `위크맵`에서 자동으로 삭제됩니다.   
```js
let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // 참조를 덮어씀

// john을 나타내는 객체는 이제 메모리에서 지워집니다!
```
<br/><br/>

`맵`과 `위크맵`의 두 번째 차이는 `위크맵`은 반복 작업과 `keys()`, `values()`, `entries()` 메서드를 지원하지 않는다는 점입니다.   
위크맵이 지원하는 메서드는 단출합니다.

- `weakMap.get(key)`
- `weakMap.set(key, value)`
- `weakMap.delete(key)`
- `weakMap.has(key)`

적은 메서드만 제공하는 이유는 가비지 컬렉션의 동작 방식 때문입니다.    
위 예시의 `john`을 나타내는 객체처럼, 객체는 모든 참조를 잃게 되면 자동으로 가비지 컬렉션의 대상이 됩니다.    
그런데 가비지 컬렉션의 ***동작 시점*** 은 정확히 알 수 없습니다.   

가비지 컬렉션이 일어나는 시점은 자바스크립트 엔진이 결정합니다.    
객체는 모든 참조를 잃었을 때, 그 즉시 메모리에서 삭제될 수도 있고, 다른 삭제 작업이 있을 때까지 대기하다가 함께 삭제될 수도 있습니다.    
***현재 위크맵에 요소가 몇 개 있는지 정확히 파악하는 것 자체가 불가능한 것이죠.***     
따라서 위크맵의 요소(키/값) 전체를 대상으로 무언가를 하는 메서드는 동작 자체가 불가능합니다.


<br/>

### 유스 케이스: 추가 데이터
`위크맵`은 ***부차적인 데이터를 저장*** 할 곳이 필요할 때 그 진가를 발휘합니다.

아래에 사용자의 방문 횟수를 세어 주는 코드가 있습니다.   
관련 정보는 맵에 저장하고 있는데 맵 요소의 키엔 특정 사용자를 나타내는 객체를, 값엔 해당 사용자의 방문 횟수를 저장하고 있습니다.    
어떤 사용자의 정보를 저장할 필요가 없어지면(가비지 컬렉션의 대상이 되면) 해당 사용자의 방문 횟수도 저장할 필요가 없어질 겁니다.   
애플리케이션 구조가 복잡할 땐, 이렇게 쓸모 없는 데이터를 수동으로 비워주는 게 꽤 골치 아픕니다.   

이런 문제는 `위크맵`을 사용해 예방할 수 있습니다.
```js
// 📁 visitsCount.js
let visitsCountMap = new WeakMap(); // 위크맵에 사용자의 방문 횟수를 저장함

// 사용자가 방문하면 방문 횟수를 늘려줍니다.
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
```
```js
// 📁 main.js
let john = { name: "John" };

countUser(john); // John의 방문 횟수를 증가시킵니다.

// John의 방문 횟수를 셀 필요가 없어지면 아래와 같이 john을 null로 덮어씁니다.
john = null;
```
`위크맵`을 사용해 사용자 방문 횟수를 저장하면 `visitsCountMap`을 수동으로 청소해줄 필요가 없습니다.    
`john`을 나타내는 객체가 도달 가능하지 않은 상태가 되면 자동으로 메모리에서 삭제되기 때문입니다.    
`위크맵`의 키(`john`)에 대응하는 값(john의 방문 횟수)도 자동으로 가비지 컬렉션의 대상이 됩니다.

<br/>

### 유스 케이스: 캐싱
동일한 함수를 여러 번 호출하면 최초 호출할 때만 연산이 수행되고, 그 이후엔 연산 결과를 cache에서 가져옵니다.   
그런데 맵을 사용하면 객체가 필요 없어져도 cache를 수동으로 청소해 줘야 합니다.   

맵을 위크맵으로 교체하면 이런 문제를 예방할 수 있습니다.    
객체가 메모리에서 삭제되면, 캐시에 저장된 결과(함수 연산 결과) 역시 메모리에서 자동으로 삭제되기 때문입니다.

<br/>

# 위크셋(WeakSet)
- 위크셋은 셋과 유사한데, 객체만 저장할 수 있다는 점이 다릅니다. 원시값은 저장할 수 없습니다.
- 셋 안의 객체는 도달 가능할 때만 메모리에서 유지됩니다.
- `add`, `has`, `delete`를 사용할 수 있고, `size`, `keys()`나 반복 작업 관련 메서드는 사용할 수 없습니다.



<br/><br/><br/>

출처: https://ko.javascript.info/weakmap-weakset
