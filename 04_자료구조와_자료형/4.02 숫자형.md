```
📍 [요약]
- 
```

# 숫자형

모던 자바스크립트는 숫자를 나타내는 두 가지 자료형을 지원합니다.

1. 일반적인 숫자는 '배정밀도 부동소수점 숫자(double precision floating point number)'로 알려진 64비트 형식의 IEEE-754에 저장됩니다.
2. 2^{53} 이상이거나 -2^{53} 이하의 수는 BigInt 자료형을 사용해 저장합니다.

<br>

## 숫자를 입력하는 다양한 방법

큰 수는 실수를 피하기 위해 다음과 같이 표현할 수 있습니다.

* `1bn` : 10억 (billion)
* `1e9` : 10억 (1과 9개의 0)
* `1e-6` : 1마이크로초 (1에서 왼쪽으로 6번 소수점 이동)

<br>

### 16진수, 2진수, 8진수

* `0x` : 16진수
* `0b` : 2진수
* `0o` : 8진수

이 외는 `parseInt(str[, radix])`를 사용해야 합니다.

<br>

## toString(base)

`num.toString(base)` 메서드는 base(2~36)진법으로 num을 표현한 후, 이를 문자형으로 변환해 반환합니다.

16진수는 색/문자 인코딩을 표현할 때, 2진수는 비트 연산 디버깅에, 36진수는 url 등 숫자로 된 긴 식별자를 짧게 줄일 때 유용합니다.

숫자를 대상으로 메서드를 직접 호출하려면 `123..toString()` 처럼 `..`를 사용합니다. 혹은 `(123).toString()`도 가능합니다.

<br>

## 어림수(rounding) 구하기

* `Math.floor`
* `Math.ceil`
* `Math.round`
* `Math.trunc`

소수점 n-th번째 수를 기준으로 어림수를 구해야 하는 상황이라면 어떻게 해야 할까요?

1. 두번째 자리 숫자까지 남기고 싶은 경우, 숫자에 100 또는 100보다 큰 10의 거듭제곱 수를 곱한 후, 
어림수 내장 함수를 호출하고 처음 곱한 수를 다시 나눕니다.
2. 소수점 n 번째 수까지의 어림수를 구한 후 문자형으로 반환해주는 `toFixed(n)`를 사용합니다.

<br>

## 부정확한 계산

숫자는 내부적으로 64비트 형식 IEEE-754으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요합니다.
그 중 52비트는 숫자를, 11비트는 소수점 위치를(정수는 0), 1비트는 부호를 저장하는 데 사용됩니다.
그런데 숫자가 너무 커지면 64비트 공간이 넘쳐서 Infinity로 처리됩니다.

또한 정밀도 손실(loss of precision)도 발생할 수 있습니다.
숫자는 이진수로 변환되어 연속된 메모리 공간에 저장되는데, `0.1`, `0.2`는 이진법으로 표현하면 무한 소수입니다.
따라서 2진법을 사용해 **정확하게** 저장하는 방법은 없습니다.
IEEE-754에선 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 이런 문제를 해결합니다. 그러나 실제 손실은 발생합니다.

다음 방법으로 문제를 해결할 수 있습니다:

1. `toFixed(n)` 메서드를 사용해 어림수를 만듭니다. (`+(0.1 + 0.2).toFixed(2)`)
2. 100(또는 더 큰 숫자)을 곱하여 정수로 바꾸고, 원하는 연산을 한 후 다시 100으로 나눕니다. 단, 나눗셈으로 소수가 다시 등장할 수 있습니다.

<br>

### 두 종류의 0
`0`과 `-0`이라는 두 종류의 0이 존재합니다. 대부분의 연산은 둘을 동일하게 취급합니다.

<br>

## isNaN과 isFinite

`Infinity`, `-Infinity`, `NaN`은 숫자형에 속하지만 ‘정상적인’ 숫자는 아니기 때문에 구분하기 위한 특별한 함수가 존재합니다.

* `isNaN(value)` : `NaN`은 자기 자신을 포함하여 그 어떤 값과도 같지 않기 때문에 `NaN === NaN`은 `false` 입니다.
* `isFinite(value)` : `NaN/Infinity/-Infinity`가 아니라면 `true`를 반환합니다. 

<br>

### `Object.is` 와 비교하기

`Object.is`와 `===`는 대부분 결과가 같지만, 두 가지 에지 케이스에선 `Object.is`가 좀 더 정확합니다.
`Object.is`에서 사용되는 비교방식은 명세서에서 'SameValue'라고 불립니다.

1. `Object.is(NaN, NaN) === true`
2. `Object.is(0, -0) === false`

<br>

## parseInt와 parseFloat

`+` 또는 `Number()`로 형변환할 땐 숫자가 아닌 기호가 섞여 있으면 형변환에 실패합니다.

`parseInt(str[, radix])`와 `parseFloat`는 불가능할 때까지 문자열에서 숫자를 추출해 형변환합니다.
읽을 수 있는 숫자가 없다면 `NaN`을 반환합니다.

<br>

## 기타 수학 함수

내장 객체 Math엔 다양한 수학 관련 함수와 상수들이 들어있습니다.

* `Math.random()`
* `Math.max(a, b, c...)` / `Math.min(a, b, c...)`
* `Math.pow(n, power)`
