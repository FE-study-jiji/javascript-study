### 01 클래스와 기본 문법

- 클래스는 함수의 한 종류입니다. (함수처럼 다른 표현식 내부에서 정의, 전달, 반환, 할당할 수 있습니다)
- 하는 일은 다음과 같습니다:   
  - 클래스 이름을 가진 함수를 만듭니다. 함수 본문은 constructor에서 가져오고(없으면 빈), 클래스 내 정의된 메서드는 prototype에 저장합니다.  
  - `new Class()`가 호출되면, 새로운 객체가 생성된 후 constructor가 실행되어 초기화합니다.   
  - 객체의 메서드를 호출하면 prototype을 통해 실행합니다.
- 생성자 함수와 비슷하나 중요한 차이가 몇가지 있습니다.
- getter, setter, 계산된 프로퍼티(및 메서드 이름)를 지원합니다.
- 클래스 필드 문법으로 어떤 종류의 프로퍼티도 클래스에 추가할 수 있습니다.  
  클래스 내부에서 `이름 = 값`으로 선언하면 클래스.prototype 이 아닌 개별 객체에만 설정됩니다.   
  특히, 이를 통해 메서드의 this를 바인딩할 수 있습니다.

### 02 클래스 상속

1. 클래스 확장하기: `class Child extends Parent`  
   `자식.prototype.[[Prototype]]`을 `부모.prototype`으로 설정합니다.
2. 메서드 오버라이딩:  
   자체적으로 정의하면 덮어씁니다.  
   부모 메서드를 토대로 일부 기능만 변경하려면 `super`를 사용합니다.    
   `super.method()`는 부모 메서드를 호출하고 `super()`는 생성자를 호출합니다.  
   (화살표 함수엔 `super`가 없으며, 외부 함수에서 가져옵니다)
3. 생성자 오버라이딩:  
   상속받은 클래스에는 `super`만 있는 '빈' constructor가 자동으로 생성됩니다.  
   커스텀 생성자를 사용하려면 `this`를 사용하기 이전에 반드시 `super`를 호출해야 합니다. 자바스크립트는 일반 클래스와 상속받은 클래스의 생성자를 구분하는데, 상속 클래스의 생성자 함수가 `new`와 함께 실행될 땐 일반 클래스에서 일어난 일이 일어나지 않고 이를 부모 클래스의 생성자가 처리해주길 기대하기 때문입니다.
4. 클래스 필드 오버라이딩
5. super와 `[[HomeObject]]`  
   연속 체이닝은 `this.__proto__`의 무한 루프에 빠질 수 있습니다.
   이를 해결하기 위해 `super`는 함수 전용 특수 내부 프로퍼티 `[[HomeObject]]`에 자신이 정의된 클래스와 객체를 기억해놓습니다.

### 03 정적 메서드와 정적 프로퍼티

- `static` 키워드가 붙은 정적 메서드/프로퍼티는 `prototype`이 아닌, 즉 특정 클래스 인스턴스가 아닌 클래스 함수 자체에 만드는 메서드/프로퍼티입니다. (기술적으론 함수에 프로퍼티 형태로 직접 할당하는 것과 동일하게 동작합니다) 인스턴스끼리 비교하는 메서드 등에 사용합니다.
- 상속이 가능합니다.  
  `class Parent extends Child`는 (기존에 봤듯이 `Child.prototype`이 `Parent.prototype`을 가리키게할 뿐 아니라,) 클래스 `Child`의 `[[Prototype]]`(클래스는 함수이고, 함수는 객체이므로)이 `Parent`를 참조하게 합니다. 즉, 두 개의 프로토타입 참조를 만듭니다.

### 04 private, protected 프로퍼티와 메서드

- 객체 지향 프로그래밍에서 내부/외부 인터페이스를 구분하는 것을 캡슐화(encapsulation)라고 합니다.
- 내부 인터페이스를 숨기기 위해 protected 나 private 프로퍼티를 사용합니다.
- protected 프로퍼티는 앞에 밑줄 `_`을 붙여 표시합니다. 상속됩니다. 언어적으로 지원되지 않습니다.
- private 프로퍼티는 앞에 `#`을 붙여 표시합니다. 언어 자체에서 강제되며, 상속되지 않습니다. 클래스 안에서만 접근할 수 있습니다.
- getter setter를 사용합니다. `get/set` 문법보다 `get.../set...` 형식의 함수가 선호됩니다. 

### 05 내장 클래스 확장하기

- 내장 클래스를 확장한 클래스의 인스턴스에서 `filter` 등 내장 메서드를 사용하면, 
  객체의 `constructor`를 사용하여 상속받은 클래스의 인스턴스(객체)를 반환합니다.
- 이 동작 방식을 바꾸고 싶다면 특수 정적 getter인 `Symbol.species`를 클래스에 추가하여 사용할 생성자를 반환합니다.
- 내장 객체 간의 상속시 정적 메서드는 상속받지 못합니다.

### 06 'instanceof'로 클래스 확인하기

- `obj instanceof Class`는 `obj`가 `Class`에 속하거나 `Class`를 상속받는지 확인합니다.
  클래스에 정적 메서드 `Symbol.hasInstance`가 구현되어있으면, `Class[Symbol.hasInstance](obj)`가 호출되고,
  아니라면 일반적인 로직으로 `Class.prototype`이 `obj` 프로토타입 체인 중 하나와 일치하는지 확인합니다.
- 비슷한 메서드로 `objA.isPrototypeOf(objB)`도 있지만, Class 생성자를 제외하고 검사한다는 특징이 있습니다.
- `Object.prototype.toString`을 사용해 타입 확인을 넘어 타입을 문자열 형태로 받을 수도 있습니다.

### 07 믹스인

- 단일상속만을 허용하는 자바스크립트에서, 믹스인은 상속받지 않고도 메서드를 사용할 수 있게 해줍니다.
- 메서드 여러 개가 담긴 믹스인 객체를 하나 만들어 `Object.assign(클래스.prototype, 믹스인)`으로 복사합니다.
- 믹스인 안에서 믹스인 상속 가능
- 이벤트 믹스인
